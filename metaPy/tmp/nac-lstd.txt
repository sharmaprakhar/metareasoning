    def run_nac_lstd(self, env):
        #WEIGHT INITIALIZATION PENDING --- init w !!
        print('Running NAC-LSTD on:', env.___name___)
        self.mini_method(env)
        numactions = len(self.params['actions'])
        numfeatures = self.psi.shape[0]
        theta, lamda, A, b, z_stat = init_interface(numfeatures, numactions)
        RAS_mean = np.zeros((self.params['trials'], self.params['episodes']))
        ti = 0
        for t in range(self.params['trials']):
            z_stat.fill(0)
            for e in range(self.params['episodes']):
                s=env.reset()
                r_cum=0
                #z_stat.fill(0) #reset z after every episode
                # for ti in range(timesteps):
                while True:
                    ti += 1
                    self.psi = self.fn.calculate_fourier(s)
                    actionProbabilities = getactionProbabilities(self.psi, numactions, theta)
                    a = getAction(actionProbabilities, self.params['actions'])
                    s_prime, r, done = env.step(a)
                    r_cum += r
                    if r==0:
                        break
                    psi2 = self.fn.calculate_fourier(s_prime) #column vector
                    dlnpi_result = dlnpi(self.psi, theta, numactions, a, numfeatures)
                    phi_tilde = np.concatenate((psi2, np.zeros((numfeatures*numactions,1))), axis=0) #column vector
                    phi_hat = np.concatenate((self.psi, dlnpi_result.T), axis=0) #dlnpi_result.T - row vector, phi_hat - column vector
                    z_stat = lamda * z_stat + phi_hat
                    A = A + np.outer(z_stat, (phi_hat - self.params['gamma'] * phi_tilde)) 
                    b = b + z_stat * r
                    if ti%10==0: #hyperparameter
                        A_inv = np.linalg.pinv(A)
                        v_w_update = A_inv.dot(b) #separate the two!!
                        w = v_w_update[numfeatures : numfeatures+(numfeatures * numactions)]
                        w_norm = np.linalg.norm(w)
                        w = w/w_norm
                        theta = theta + self.params['alpha']*w
                        z_stat = z_stat*0
                        A = A * 0
                        b = b * 0
                RAS_mean[t][e] = r_cum
                # print("NAC_LSTD: total_reward for Trial {2} episode {0} : {1}".format(e,r_cum,t))
        plot_mean(RAS_mean)
        # return mean, std