def run_nac_lstd(self, env):
    #WEIGHT INITIALIZATION PENDING --- init w !!
    print('Running NAC-LSTD on:', env.___name___)
    self.mini_method(env)
    numactions = len(self.params['actions'])
    numfeatures = self.psi.shape[0]
    theta, lamda, A, b, z_stat = init_interface(numfeatures, numactions)
    RAS_mean = np.zeros((self.params['trials'], self.params['episodes']))
    ti = 0
    for t in range(self.params['trials']):
        z_stat.fill(0)
        for e in range(self.params['episodes']):
            s=env.reset()
            r_cum=0
            #z_stat.fill(0) #reset z after every episode
            # for ti in range(timesteps):
            while True:
                ti += 1
                self.psi = self.fn.calculate_fourier(s)
                actionProbabilities = getactionProbabilities(self.psi, numactions, theta)
                a = getAction(actionProbabilities, self.params['actions'])
                s_prime, r, done = env.step(a)
                r_cum += r
                if r==0:
                    break
                psi2 = self.fn.calculate_fourier(s_prime) #column vector
                dlnpi_result = dlnpi(self.psi, theta, numactions, a, numfeatures)
                phi_tilde = np.concatenate((psi2, np.zeros((numfeatures*numactions,1))), axis=0) #column vector
                phi_hat = np.concatenate((self.psi, dlnpi_result.T), axis=0) #dlnpi_result.T - row vector, phi_hat - column vector
                z_stat = lamda * z_stat + phi_hat
                A = A + np.outer(z_stat, (phi_hat - self.params['gamma'] * phi_tilde)) 
                b = b + z_stat * r
                if ti%10==0: #hyperparameter
                    A_inv = np.linalg.pinv(A)
                    v_w_update = A_inv.dot(b) #separate the two!!
                    w = v_w_update[numfeatures : numfeatures+(numfeatures * numactions)]
                    w_norm = np.linalg.norm(w)
                    w = w/w_norm
                    theta = theta + self.params['alpha']*w
                    z_stat = z_stat*0
                    A = A * 0
                    b = b * 0
            RAS_mean[t][e] = r_cum
            # print("NAC_LSTD: total_reward for Trial {2} episode {0} : {1}".format(e,r_cum,t))
    plot_mean(RAS_mean)
    # return mean, std


def dlnpi(features, theta, num_actions, action, num_features):
    action += 1

    action_probabilities = get_action_probabilities(features, num_actions, theta)

    result = np.zeros((1, (num_actions * num_features)))
    for i in range(num_actions):
        if i == action:
            result[0, num_features*action : (num_features * action + num_features)] = features.T * (1 - action_probabilities[action])
        else:
            result[0, num_features * i : (num_features * i + num_features)] = -1 * features.T * action_probabilities[i]

    return result


def init_interface(num_features, num_actions, l=0.999):
    num_theta = num_features * num_actions

    theta = np.zeros((num_features * num_actions, 1))
    A = np.zeros((num_features + num_theta, num_features + num_theta))
    b = np.zeros((num_features + num_theta, 1))
    z_stat = np.zeros((num_features + num_theta, 1))

    return theta, l, A, b, z_stat


def get_action_probabilities(features, num_actions, theta):
    action_probabilities = np.zeros((num_actions))

    num_features = len(features)

    for i in range(num_actions):
        start_index = num_features * i
        end_index = num_features * i + num_features
        action_probabilities[i] = features.T.dot(theta[start_index:end_index])

    action_probabilities_exp = np.exp(action_probabilities)
    action_probabilities_sum = np.sum(action_probabilities_exp)
    action_probabilities = action_probabilities_exp / action_probabilities_sum

    return action_probabilities


def plot_mean(arr):
    mean = arr.mean(axis=0, keepdims=True)
    mean = mean.reshape(mean.shape[1])

    std = np.std(arr, axis=0, keepdims=True)
    std = std.reshape(std.shape[1])

    plot_data(mean, std)


def get_action(action_probabilities, actions):
    return np.random.choice(actions, p=action_probabilities)


def plot_data(y_data, yerr=None, x_data=None):
    if not x_data:
        x_axis = range(len(y_data))

    plt.errorbar(x_axis, y_data, yerr=yerr, ecolor="r")
    plt.title("Performance")
    plt.xlabel("Episodes")
    plt.ylabel("Cumulative Reward")
    plt.grid(True)
    plt.show()
